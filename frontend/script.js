document.addEventListener('DOMContentLoaded', () => {
    const app = new StockDashboard();
    app.init();
});

class StockDashboard {
    constructor() {
        // Elements
        this.tableBody = document.getElementById('stock-table-body');
        this.lastUpdatedEl = document.getElementById('last-updated');
        this.refreshBtn = document.getElementById('refresh-btn');
        this.themeSwitch = document.getElementById('theme-switch');
        this.changePeriodSelect = document.getElementById('change-period');
        this.drawdownPeriodSelect = document.getElementById('drawdown-period');

        // Popup Elements
        this.popup = document.getElementById('chart-popup');
        this.popupTitle = document.getElementById('popup-title');
        this.popupPrice = document.getElementById('popup-price');
        this.popupCanvas = document.getElementById('popup-canvas');
        this.chartInstance = null;

        // State
        this.marketData = {};
        this.assetData = [];
        this.spyHistory = null;
        this.sortColumn = 'type';
        this.sortDirection = 'asc';
        this.isRefreshing = false;

        // Config
        this.apiEndpoint = '/api/dashboard-data';
    }

    init() {
        this.setupEventListeners();
        this.loadTheme();
        this.fetchData();

        // Auto-refresh every 60s
        setInterval(() => this.fetchData(), 60000);
    }

    setupEventListeners() {
        // Refresh Button
        this.refreshBtn.addEventListener('click', () => this.fetchData());

        // Theme Toggle
        this.themeSwitch.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            }
        });

        // Period Selects
        this.changePeriodSelect.addEventListener('change', () => this.fetchData());
        this.drawdownPeriodSelect.addEventListener('change', () => this.fetchData());

        // Sorting
        document.querySelectorAll('th[data-sort]').forEach(th => {
            th.addEventListener('click', () => {
                const column = th.dataset.sort;
                this.handleSort(column);
            });
        });
    }

    loadTheme() {
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        this.themeSwitch.checked = savedTheme === 'light';
    }

    async fetchData() {
        if (this.isRefreshing) return;
        this.isRefreshing = true;
        this.refreshBtn.classList.add('loading');
        this.refreshBtn.querySelector('.btn-text').textContent = 'Refreshing...';

        try {
            // Fetch static data.json generated by GitHub Actions
            const response = await fetch('data.json');
            if (!response.ok) throw new Error('Network response was not ok');

            const data = await response.json();

            this.marketData = data.market_data || {};
            this.assetData = Object.values(data.asset_data || {});
            this.spyHistory = data.spy_1y_history;

            this.renderTable();

            // Update with generation timestamp from data
            if (data.generated_at) {
                const genDate = new Date(data.generated_at);
                this.lastUpdatedEl.textContent = `Last Updated: ${genDate.toLocaleTimeString()}`;
            } else {
                this.updateLastUpdated();
            }

        } catch (error) {
            console.error('Error fetching data:', error);
            this.showError(`Error fetching data: ${error.message}`);
        } finally {
            this.hideLoading();
        }
    }

    showError(message) {
        this.lastUpdatedEl.textContent = message;
        this.lastUpdatedEl.style.color = '#ef4444'; // Red color for error
    }

    hideLoading() {
        this.isRefreshing = false;
        this.refreshBtn.classList.remove('loading');
        this.refreshBtn.querySelector('.btn-text').textContent = 'Refresh';
    }

    updateLastUpdated() {
        const now = new Date();
        this.lastUpdatedEl.textContent = `Last Updated: ${now.toLocaleTimeString()}`;
    }

    handleSort(column) {
        if (this.sortColumn === column) {
            this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            this.sortColumn = column;
            this.sortDirection = 'desc'; // Default to desc for numbers usually
        }

        // Update header styles
        document.querySelectorAll('th').forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sort === column) {
                th.classList.add(this.sortDirection);
            }
        });

        this.renderTable();
    }

    sortData(data) {
        return [...data].sort((a, b) => {
            let valA = a[this.sortColumn];
            let valB = b[this.sortColumn];

            // Handle specific columns
            if (this.sortColumn === 'name') {
                valA = a.display_name || a.name;
                valB = b.display_name || b.name;
            }

            // Handle nulls
            if (valA == null) valA = -Infinity;
            if (valB == null) valB = -Infinity;

            if (valA < valB) return this.sortDirection === 'asc' ? -1 : 1;
            if (valA > valB) return this.sortDirection === 'asc' ? 1 : -1;
            return 0;
        });
    }

    renderTable() {
        this.tableBody.innerHTML = '';

        // 1. Render Market Data (Fixed at top)
        const marketOrder = ['SPY', '^DJI', '^GSPC', '^VIX'];
        marketOrder.forEach(symbol => {
            const stock = this.marketData[symbol];
            if (stock) this.renderRow(stock, true);
        });

        // Separator after market data
        const separator = document.createElement('tr');
        separator.innerHTML = '<td colspan="17" style="height: 20px; background: transparent; border: none;"></td>';
        this.tableBody.appendChild(separator);

        // 2. Group assets by type
        const etfs = [];
        const stocks = [];
        const crypto = [];

        this.assetData.forEach(asset => {
            if (asset.type === 'ETF') {
                etfs.push(asset);
            } else if (asset.type === 'Crypto') {
                crypto.push(asset);
            } else {
                stocks.push(asset);
            }
        });

        // Sort each group
        const sortedEtfs = this.sortData(etfs);
        const sortedStocks = this.sortData(stocks);
        const sortedCrypto = this.sortData(crypto);

        // Render ETFs with header
        if (sortedEtfs.length > 0) {
            this.renderGroupHeader('ETFs');
            sortedEtfs.forEach(stock => this.renderRow(stock, false));
        }

        // Render Stocks with header
        if (sortedStocks.length > 0) {
            this.renderGroupHeader('Stocks');
            sortedStocks.forEach(stock => this.renderRow(stock, false));
        }

        // Render Crypto with header
        if (sortedCrypto.length > 0) {
            this.renderGroupHeader('Crypto');
            sortedCrypto.forEach(stock => this.renderRow(stock, false));
        }
    }

    renderGroupHeader(groupName) {
        const headerRow = document.createElement('tr');
        headerRow.className = 'group-header';
        headerRow.innerHTML = `<td colspan="17"><strong>${groupName}</strong></td>`;
        this.tableBody.appendChild(headerRow);
    }

    renderRow(stock, isMarket) {
        if (stock.name === 'AAPL') console.log('DEBUG AAPL stock data:', stock);
        const tr = document.createElement('tr');
        tr.className = isMarket ? 'market-row' : 'asset-row';

        // Helper for formatting
        const fmt = (num, decimals = 2) => num != null ? num.toFixed(decimals) : '--';
        const colorClass = (val) => val > 0 ? 'positive' : (val < 0 ? 'negative' : '');

        // Signal Badge
        const signal = stock.ema_signal || 'Neutral';
        const signalClass = signal === 'Buy' ? 'signal-buy' : (signal === 'Sell' ? 'signal-sell' : '');

        // Format alpha (relative_perf_1y)
        const alpha = stock.relative_perf_1y;
        const alphaText = alpha != null ? `${alpha > 0 ? '+' : ''}${fmt(alpha)}%` : '--';
        const alphaColorClass = colorClass(alpha);

        tr.innerHTML = `
            <td class="symbol-cell">
                <div>${stock.name}</div>
                <span class="name-sub">${stock.display_name || ''}</span>
            </td>
            <td class="price-cell">$${fmt(stock.latest_price)}</td>
            <td class="alpha-cell ${alphaColorClass}">
                ${alphaText}
            </td>
            <td class="change-cell ${colorClass(stock.daily_change_pct)}">
                ${fmt(stock.daily_change_pct)}%
            </td>
            <td class="trend-cell">
                <!-- Sparkline SVG injected here -->
            </td>
            <td class="rsi-cell ${stock.rsi14 > 70 ? 'rsi-overbought' : (stock.rsi14 < 30 ? 'rsi-oversold' : '')}">
                ${fmt(stock.rsi14, 1)}
            </td>
            <td class="zscore-cell ${colorClass(stock.z_score_100 * -1)}">
                ${fmt(stock.z_score_100)}
            </td>
            <td>${fmt(stock.ema13)}</td>
            <td>${fmt(stock.ema21)}</td>
            <td>
                <span class="signal-badge ${signalClass}">${signal}</span>
            </td>
            <td>${this.calculateDuration(stock.ema_signal, stock.ema_short_last_buy_date)}</td>
            <td>${fmt(stock.ema100)}</td>
            <td>${fmt(stock.ema200)}</td>
            <td>
                <span class="signal-badge ${stock.ema_long_signal === 'Buy' ? 'signal-buy' : (stock.ema_long_signal === 'Sell' ? 'signal-sell' : '')}">
                    ${stock.ema_long_signal || 'Neutral'}
                </span>
            </td>
            <td>${this.calculateDuration(stock.ema_long_signal, stock.ema_long_last_buy_date)}</td>
            <td class="drawdown-cell negative">
                ${fmt(stock.current_drawdown_pct)}%
            </td>
        `;

        // Inject Sparkline
        const trendCell = tr.querySelector('.trend-cell');
        if (stock.sparkline_data && stock.sparkline_data.length > 0) {
            trendCell.appendChild(this.createSparkline(stock.sparkline_data, stock.daily_change_pct >= 0));
        }

        // Add Hover Events for Popup
        this.addHoverEvents(tr, stock);

        this.tableBody.appendChild(tr);
    }

    calculateDuration(signal, dateStr) {
        if (!signal || !dateStr) return '';
        try {
            const date = new Date(dateStr);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return `${diffDays}d`;
        } catch (e) {
            return '';
        }
    }

    createSparkline(data, isPositive) {
        const width = 100;
        const height = 30;
        const min = Math.min(...data);
        const max = Math.max(...data);
        const range = max - min || 1;

        const points = data.map((val, i) => {
            const x = (i / (data.length - 1)) * width;
            const y = height - ((val - min) / range) * height;
            return `${x},${y}`;
        }).join(' ');

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'sparkline-canvas');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        path.setAttribute('points', points);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', isPositive ? 'var(--success)' : 'var(--danger)');
        path.setAttribute('stroke-width', '2');

        svg.appendChild(path);
        return svg;
    }

    addHoverEvents(row, stock) {
        // Hover on Symbol -> Relative Perf Chart
        const symbolCell = row.querySelector('.symbol-cell');
        symbolCell.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'rel_perf'));
        symbolCell.addEventListener('mouseleave', () => this.hidePopup());

        // Hover on Trend -> Price History
        const trendCell = row.querySelector('.trend-cell');
        trendCell.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'price'));
        trendCell.addEventListener('mouseleave', () => this.hidePopup());

        // Hover on RSI -> RSI History
        const rsiCell = row.querySelector('.rsi-cell');
        rsiCell.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'rsi'));
        rsiCell.addEventListener('mouseleave', () => this.hidePopup());

        // Hover on Drawdown -> Drawdown History
        const ddCell = row.querySelector('.drawdown-cell');
        ddCell.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'drawdown'));
        ddCell.addEventListener('mouseleave', () => this.hidePopup());

        // Hover on Z-Score -> Z-Score History (if available)
        const zScoreCell = row.querySelector('.zscore-cell');
        if (zScoreCell) {
            zScoreCell.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'zscore'));
            zScoreCell.addEventListener('mouseleave', () => this.hidePopup());
        }

        // Hover on Signal (S) -> EMA Short History
        // Find all signal badges and get the first one (Signal S)
        const signalBadges = row.querySelectorAll('.signal-badge');
        if (signalBadges.length >= 1) {
            const signalCellS = signalBadges[0].parentElement;
            signalCellS.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'ema_short'));
            signalCellS.addEventListener('mouseleave', () => this.hidePopup());
        }

        // Hover on Signal (L) -> EMA Long History
        // Get the second signal badge (Signal L)
        if (signalBadges.length >= 2) {
            const signalCellL = signalBadges[1].parentElement;
            signalCellL.addEventListener('mouseenter', (e) => this.showPopup(e, stock, 'ema_long'));
            signalCellL.addEventListener('mouseleave', () => this.hidePopup());
        }
    }

    showPopup(e, stock, type) {
        const rect = e.target.getBoundingClientRect();
        const popupWidth = 600; // Approx width
        const popupHeight = 350; // Approx height
        const margin = 20; // Margin from screen edges
        const bottomMargin = 60; // Extra buffer at bottom of page

        // Use viewport-relative positioning (fixed)
        // rect already gives us viewport coordinates, so no need to add scrollY
        let left = rect.right + margin;
        let top = rect.top;

        // Horizontal bounds checking
        // If popup would go off right edge, position to the left of the cell
        if (left + popupWidth > window.innerWidth - margin) {
            left = rect.left - popupWidth - margin;
        }

        // If still off left edge, clamp to margin
        if (left < margin) {
            left = margin;
        }

        // Final check: ensure we don't exceed right edge
        if (left + popupWidth > window.innerWidth - margin) {
            left = window.innerWidth - popupWidth - margin;
        }

        // Vertical bounds checking
        // If popup would go off bottom, shift up (with extra bottom buffer)
        if (top + popupHeight > window.innerHeight - bottomMargin) {
            top = window.innerHeight - popupHeight - bottomMargin;
        }

        // If still off top edge, clamp to margin
        if (top < margin) {
            top = margin;
        }

        // Apply positions
        this.popup.style.top = `${top}px`;
        this.popup.style.left = `${left}px`;

        this.popup.classList.add('active');
        this.popupTitle.textContent = stock.display_name || stock.name;
        this.popupPrice.textContent = `$${stock.latest_price.toFixed(2)}`;

        this.renderPopupChart(stock, type);
    }

    hidePopup() {
        this.popup.classList.remove('active');
    }

    renderPopupChart(stock, type) {
        if (this.chartInstance) {
            this.chartInstance.destroy();
        }

        const ctx = this.popupCanvas.getContext('2d');
        let labels, data, label, color, borderColor;

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
        const textColor = isDark ? '#94a3b8' : '#64748b';

        if (type === 'rel_perf') {
            labels = stock.asset_1y_history_dates;
            const stockData = stock.asset_1y_history_values;

            // Get SPY performance data
            const spyData = this.spyHistory?.values || [];

            if (!labels || !stockData) return;

            // Calculate performance difference (Alpha = Stock - SPY)
            const latestStockPerf = stockData[stockData.length - 1] || 0;
            const latestSpyPerf = spyData[spyData.length - 1] || 0;
            const performanceDiff = latestStockPerf - latestSpyPerf;
            const diffSign = performanceDiff >= 0 ? '+' : '';

            // Create datasets for multi-line chart
            const datasets = [
                {
                    label: stock.name,
                    data: stockData,
                    color: performanceDiff >= 0 ? '#10b981' : '#ef4444', // Green if outperforming, red if underperforming
                    borderDash: [] // Solid line
                }
            ];

            // Add SPY comparison line
            if (spyData.length > 0) {
                datasets.push({
                    label: 'SPY',
                    data: spyData,
                    color: '#6b7280', // Grey
                    borderDash: [5, 5] // Dotted line
                });
            }

            // Create alpha annotation text for bottom-right corner
            const alphaText = `Î±: ${diffSign}${performanceDiff.toFixed(2)}%`;

            this.renderMultiLineChart(ctx, labels, datasets, 'Relative Performance (%)', alphaText);
            return;
        } else if (type === 'rsi') {
            labels = stock.rsi_1y_history_dates;
            data = stock.rsi_1y_history_values;
            label = 'RSI (14)';
            borderColor = '#8b5cf6';
        } else if (type === 'zscore') {
            labels = stock.zscore_1y_history_dates;
            data = stock.zscore_1y_history_values;
            label = 'Log Z-Score (100d)';
            borderColor = '#a855f7'; // Purple for z-score
        } else if (type === 'drawdown') {
            labels = stock.drawdown_history_dates;
            data = stock.drawdown_history_values;
            label = 'Drawdown (%)';
            borderColor = '#ef4444';
        } else if (type === 'ema_short') {
            labels = stock.ema_1y_history_dates;
            console.log(`Debug EMA Short for ${stock.name}:`, {
                dates: labels ? labels.length : 0,
                ema13: stock.ema13_1y_history_values ? stock.ema13_1y_history_values.length : 0,
                ema21: stock.ema21_1y_history_values ? stock.ema21_1y_history_values.length : 0
            });

            // Multi-dataset for EMA
            if (!labels || !stock.ema13_1y_history_values || !stock.ema21_1y_history_values) {
                console.warn(`Missing EMA Short data for ${stock.name}`);
                return;
            }

            this.renderMultiLineChart(ctx, labels, [
                { label: 'EMA 13', data: stock.ema13_1y_history_values, color: '#3b82f6' }, // Blue
                { label: 'EMA 21', data: stock.ema21_1y_history_values, color: '#f59e0b' }  // Orange
            ]);
            return; // Exit as we used custom render
        } else if (type === 'ema_long') {
            labels = stock.ema_long_1y_history_dates;
            if (!labels || !stock.ema100_1y_history_values || !stock.ema200_1y_history_values) return;

            this.renderMultiLineChart(ctx, labels, [
                { label: 'EMA 100', data: stock.ema100_1y_history_values, color: '#10b981' }, // Green
                { label: 'EMA 200', data: stock.ema200_1y_history_values, color: '#ef4444' }  // Red
            ]);
            return;
        } else {
            // Default to price/trend (using sparkline data or history if available)
            // Ideally we'd have full history, but let's use what we have. 
            // If we have asset history, use that for better resolution than sparkline
            if (stock.asset_1y_history_dates) {
                labels = stock.asset_1y_history_dates;
                // We don't have raw price history in the response for 1y, only cum return. 
                // But we can show cum return as "Trend".
                data = stock.asset_1y_history_values;
                label = 'Return (%)';
                borderColor = stock.daily_change_pct >= 0 ? '#10b981' : '#ef4444';
            } else {
                // Fallback
                return;
            }
        }

        if (!labels || !data) return;

        this.chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: borderColor,
                    backgroundColor: borderColor + '20', // Transparent fill
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'month'
                        },
                        ticks: {
                            source: 'data', // Only show dates where data exists
                            color: textColor
                        },
                        grid: {
                            display: false,
                            drawBorder: false
                        }
                    },
                    y: {
                        grid: {
                            color: gridColor,
                            drawBorder: false
                        },
                        ticks: {
                            color: textColor
                        }
                    }
                }
            }
        });
    }

    renderMultiLineChart(ctx, labels, datasetsConfig, yAxisLabel = null, annotationText = null) {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
        const textColor = isDark ? '#94a3b8' : '#64748b';

        const datasets = datasetsConfig.map(cfg => ({
            label: cfg.label,
            data: cfg.data,
            borderColor: cfg.color,
            backgroundColor: 'transparent',
            borderWidth: 2,
            borderDash: cfg.borderDash || [], // Support dotted/dashed lines
            pointRadius: 0,
            pointHoverRadius: 4,
            tension: 0.4
        }));

        // Custom plugin to draw annotation text in bottom-right corner
        const annotationPlugin = {
            id: 'customAnnotation',
            afterDraw: (chart) => {
                if (!annotationText) return;

                const ctx = chart.ctx;
                const chartArea = chart.chartArea;

                ctx.save();
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = isDark ? 'rgba(148, 163, 184, 0.7)' : 'rgba(100, 116, 139, 0.7)';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';

                // Position in bottom-right corner with padding
                const x = chartArea.right - 10;
                const y = chartArea.bottom - 5;

                ctx.fillText(annotationText, x, y);
                ctx.restore();
            }
        };

        this.chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: true,
                        labels: { color: textColor }
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'month' },
                        ticks: {
                            source: 'data', // Only show dates where data exists
                            color: textColor
                        },
                        grid: { display: false }
                    },
                    y: {
                        grid: { color: gridColor, drawBorder: false },
                        ticks: { color: textColor },
                        ...(yAxisLabel && {
                            title: {
                                display: true,
                                text: yAxisLabel,
                                color: textColor
                            }
                        })
                    }
                }
            },
            plugins: [annotationPlugin]
        });
    }
}